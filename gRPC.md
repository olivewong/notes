# gRPC Notes
[YouTube](https://www.youtube.com/watch?v=hVrwuMnCtok)
[YouTube](https://www.youtube.com/watch?v=XRXTsQwyZSU)

## What is gRPC?
* A nice way to implement an API and deal with communication between services.
* It allows you to just define request and response for RPC (Remote Procedure Calls) and it autogenerates code in different languages for you
	* RPC isn’t new, but gRPC solves a lot of its problems
* Open-source, developed by Google and built on top of HTTP2.0
* Offers convenience, scalability, and performance benefits

## Why use gRPC?
### 1. It's convenient
* It handles all the connections to the HTTP services for you
	* Let’s say you have a backend with Go, Python and Java. All these have their own HTTP libraries (Python’s requests lib, Java HttpURLConnection)  which would time-consuming to write all the functions in each language. gRPC handles all this HTTP stuff for you by autogenerating code using *protocol buffers*
* Code generation using *protocol buffers*  `.proto`
	* Contains message schema
	* Defines which Procedures are Callable Remotely
		* You implement the actual details in each language (i.e. in `annotations.go`)

### 2. It’s performant
* Protobufs are small and fast. They’re serialized and sent as binaries across the wire.
* Faster than JSON: REST APIs use JSON by default, which is key-value and very space inefficient. Protocol buffers are smaller and more efficient in comparison.
	* 	Also, less effort than implementing compression (gzip), gRPC handles it all for you

## How do I use it?
### Adding a function
1. Define message types and services in `.proto` (`annotation_stubs.proto`) or models?
```
message SearchRequest {
  string query = 1;
  int32 page_number = 2;  // Which page number do we want?
  int32 result_per_page = 3;  // Number of results to return per page.
}
```

2. Run the scripts to compile your `.proto`  using `protoc`(this autogenerate `*pb*` code)
	1.  `.proto` generates the rest of gRPC code, can work for over 12 different programming languages. These files have the extension `.pb.go` or .`pb.ts` or whatever languages
3. You implement stuff defined in the protocol buffer `annotation.go`


### What are all these files?
  `annotation_stubs.proto` (implemented by you) 
	* Skeleton that defines what API looks like
	* Tells you everything about the service
	* From this file, generate code in other languages (see `annotation_stubs_pb.ts` and `annotation_stubs.pb.go`)
		* These let you call (.ts) and implement (.go) the API
* `pb`  files (like   `annotation_stubs_pb.ts` and `annotation_stubs.pb.go` )
	* Autogenerated - anything containing *pb* generated by the scripts

## Example 
* Frontend
* Backend server running microservices (Python, Java, Go)
	* In proto file, messages have `int`,  `string`, then you implement the details in the actual Java file

![Image](https://miro.medium.com/max/1400/1*Eg16Mg5l9l_n8O-Eer4-ug.png)

### Example.proto

```
message Greeting {
string first_name = 1;
}
message GreetRequest {
Greeting greeting = 1
}
message GreetResponse {
string result = 1;
}
service GreetService {
rpc Greet(GreetRequest) returns (GreetResponse) {};
}
```
